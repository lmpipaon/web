<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Neuronal con 9 Entradas</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .input-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input {
            width: 100px;
        }
        canvas {
            border: 1px solid #ccc;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Red Neuronal con 9 Entradas</h1>
    <form id="neuralForm">
        <div class="input-group">
            <label for="input1">Cl Set</label>
            <input type="number" id="input1" value="0.7" required>
        </div>
        <div class="input-group">
            <label for="input2">Pump</label>
            <input type="number" id="input2" value="1.6" required>
        </div>
        <div class="input-group">
            <label for="input3">UV%</label>
            <input type="number" id="input3" value="30" required>
        </div>
        <div class="input-group">
            <label for="input4">Flow</label>
            <input type="number" id="input4" value="90" required>
        </div>
        <div class="input-group">
            <label for="input5">Effluent Turbidity</label>
            <input type="number" id="input5" value="0.6" required>
        </div>
        <div class="input-group">
            <label for="input6">Tank Level</label>
            <input type="number" id="input6" value="50" required>
        </div>
        <div class="input-group">
            <label for="input7">Influent Turbidity</label>
            <input type="number" id="input7" value="1" required>
        </div>
        <div class="input-group">
            <label for="input8">pH</label>
            <input type="number" id="input8" value="7.5" required>
        </div>
        <div class="input-group">
            <label for="input9">Coagulant PPM</label>
            <input type="number" id="input9" value="2" required>
        </div>
        <button type="button" onclick="calculateOutput()">Calcular</button>
    </form>
    <h2 id="output"></h2>
    <canvas id="networkCanvas" width="800" height="600"></canvas>
    <script>
        const weightsHidden = [
            [-1.5254, -2.8213, -2.0056, -0.5310, 0.0872, -2.6420, 2.2675, 1.6801, -2.4497],
            [0.1749, 1.1470, 0.0110, 0.9485, -0.7185, -0.5225, 0.5567, -3.0506, 0.2267],
            [-0.9500, -1.6201, 0.7642, -0.7214, 0.0942, -0.7018, 1.4409, 0.2737, -2.2615],
            [-0.4291, -0.1496, -0.1680, -1.5874, 0.3165, 0.6999, 0.9615, 1.7618, -1.9396],
            [-0.4147, 1.6260, -0.9535, 1.3389, 0.4307, 0.1598, 0.8035, -1.2008, 1.5433],
            [2.5432, 2.2072, 0.4781, -2.3549, -0.0015, -0.7786, 0.1003, -0.3360, -4.3691]
        ];

        const biasesHidden = [2.1953, 0.3133, 2.1811, -0.6922, 5.7215, 2.3570];

        const weightsOutput = [2.6014, -2.9345, 2.8387, -2.7334, 4.3664, 2.6695];
        const biasOutput = 4.1839;

        const normalizationData = [
            { mu: 0.7181, sigma: 0.0714 },
            { mu: 1.6355, sigma: 0.4813 },
            { mu: 30.5615, sigma: 4.7297 },
            { mu: 92.9365, sigma: 5.4898 },
            { mu: 0.6325, sigma: 0.4388 },
            { mu: 63.6731, sigma: 13.0110 },
            { mu: 1.6341, sigma: 1.8581 },
            { mu: 8.6380, sigma: 0.4105 },
            { mu: 2.0431, sigma: 5.9868 }
        ];

        function normalize(value, mu, sigma) {
            return (value - mu) / sigma;
        }

        function relu(x) {
            return Math.max(0, x);
        }

        function calculateOutput() {
            const inputs = [
                parseFloat(document.getElementById("input1").value),
                parseFloat(document.getElementById("input2").value),
                parseFloat(document.getElementById("input3").value),
                parseFloat(document.getElementById("input4").value),
                parseFloat(document.getElementById("input5").value),
                parseFloat(document.getElementById("input6").value),
                parseFloat(document.getElementById("input7").value),
                parseFloat(document.getElementById("input8").value),
                parseFloat(document.getElementById("input9").value)
            ];

            const normalizedInputs = inputs.map((value, index) =>
                normalize(value, normalizationData[index].mu, normalizationData[index].sigma)
            );

            const hiddenLayerOutputs = weightsHidden.map((weights, neuronIndex) => {
                const sum = weights.reduce((acc, weight, inputIndex) => 
                    acc + weight * normalizedInputs[inputIndex], biasesHidden[neuronIndex]
                );
                return relu(sum);
            });

            const output = hiddenLayerOutputs.reduce((acc, value, index) =>
                acc + value * weightsOutput[index], biasOutput
            );

            document.getElementById("output").innerText = `Output: ${output.toFixed(4)}`;
            drawNetwork(normalizedInputs, hiddenLayerOutputs, output);
        }

        function drawNetwork(inputs, hiddenOutputs, output) {
            const canvas = document.getElementById("networkCanvas");
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const inputLayerX = 100;
            const hiddenLayerX = 400;
            const outputLayerX = 700;

            const inputSpacing = 50;
            const hiddenSpacing = 70;

            const inputPositions = inputs.map((input, i) => {
                const y = 100 + i * inputSpacing;
                ctx.beginPath();
                ctx.arc(inputLayerX, y, 20, 0, Math.PI * 2);
                ctx.fillStyle = "#3498DB";
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "black";
                ctx.fillText(`x${i + 1}: ${input.toFixed(2)}`, inputLayerX - 75, y);
                return { x: inputLayerX, y };
            });

            const hiddenPositions = hiddenOutputs.map((output, i) => {
                const y = 150 + i * hiddenSpacing;
                ctx.beginPath();
                ctx.arc(hiddenLayerX, y, 20, 0, Math.PI * 2);
                ctx.fillStyle = "#E74C3C";
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "black";
                ctx.fillText(`h${i + 1}: ${output.toFixed(2)}`, hiddenLayerX - 75, y);
                return { x: hiddenLayerX, y };
            });

            const outputPosition = { x: outputLayerX, y: 300 };
            ctx.beginPath();
            ctx.arc(outputPosition.x, outputPosition.y, 20, 0, Math.PI * 2);
            ctx.fillStyle = "#2ECC71";
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.fillText(`y: ${output.toFixed(2)}`, outputPosition.x - 40, outputPosition.y);

            inputPositions.forEach(inputPos => {
                hiddenPositions.forEach(hiddenPos => {
                    ctx.beginPath();
                    ctx.moveTo(inputPos.x, inputPos.y);
                    ctx.lineTo(hiddenPos.x, hiddenPos.y);
                    ctx.stroke();
                });
            });

            hiddenPositions.forEach(hiddenPos => {
                ctx.beginPath();
                ctx.moveTo(hiddenPos.x, hiddenPos.y);
                ctx.lineTo(outputPosition.x, outputPosition.y);
                ctx.stroke();
            });
        }
    </script>
</body>
</html>
