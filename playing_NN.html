<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 20px;
            background-color: #f4f4f4;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px;
        }

        .form-container {
            width: 25%; /* Formulario más pequeño */
            background: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 10px;
            box-sizing: border-box;
        }

        .input-group {
            margin-bottom: 5px;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        .output {
            margin-top: 20px;
            font-size: 18px;
        }

        canvas {
            width: 70%;
            height: 500px; /* Mayor altura para visualizar la red de forma horizontal */
            background-color: #f0f0f0;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Formulario para introducir los datos -->
        <div class="form-container">
            <form id="nn-form">
                <div class="input-group">
                    <label for="tankLevel">Tank Level</label>
                    <input type="number" id="tankLevel" required>
                </div>
                <div class="input-group">
                    <label for="clSet">Cl Set</label>
                    <input type="number" id="clSet" required>
                </div>
                <div class="input-group">
                    <label for="pump">Pump</label>
                    <input type="number" id="pump" required>
                </div>
                <div class="input-group">
                    <label for="uv">UV%</label>
                    <input type="number" id="uv" required>
                </div>
                <div class="input-group">
                    <label for="flow">Flow</label>
                    <input type="number" id="flow" required>
                </div>
                <div class="input-group">
                    <label for="infTurb">Influent Turbidity</label>
                    <input type="number" id="infTurb" required>
                </div>
                <div class="input-group">
                    <label for="effTurb">Effluent Turbidity</label>
                    <input type="number" id="effTurb" required>
                </div>
                <div class="input-group">
                    <label for="ph">pH</label>
                    <input type="number" id="ph" required>
                </div>
                <div class="input-group">
                    <label for="coagPPM">Coag PPM</label>
                    <input type="number" id="coagPPM" required>
                </div>
                <button type="button" onclick="calculateOutput()">Calculate</button>
            </form>
            <div class="output" id="output"></div>
        </div>

        <!-- Canvas para el gráfico de la red -->
        <canvas id="nn-canvas" width="800" height="500"></canvas>
    </div>

    <script>
        // Pesos y sesgos
        const weightsHidden = [
            [-1.5254, -2.8213, -2.0056, -0.5310, 0.0872, -2.6420, 2.2675, 1.6801, -2.4497],
            [0.1749, 1.1470, 0.0110, 0.9485, -0.7185, -0.5225, 0.5567, -3.0506, 0.2267],
            [-0.9500, -1.6201, 0.7642, -0.7214, 0.0942, -0.7018, 1.4409, 0.2737, -2.2615],
            [-0.4291, -0.1496, -0.1680, -1.5874, 0.3165, 0.6999, 0.9615, 1.7618, -1.9396],
            [-0.4147, 1.6260, -0.9535, 1.3389, 0.4307, 0.1598, 0.8035, -1.2008, 1.5433],
            [2.5432, 2.2072, 0.4781, -2.3549, -0.0015, -0.7786, 0.1003, -0.3360, -4.3691]
        ];

        const biasesHidden = [2.1953, 0.3133, 2.1811, -0.6922, 5.7215, 2.3570];

        const weightsOutput = [2.6014, -2.9345, 2.8387, -2.7334, 4.3664, 2.6695];
        const biasOutput = 4.1839;

        // Datos de normalización
        const normalizationData = [
            { mu: 63.6731, sigma: 13.0110 }, // Tank Level
            { mu: 0.7181, sigma: 0.0714 },   // Cl Set
            { mu: 1.6355, sigma: 0.4813 },   // Pump
            { mu: 30.5615, sigma: 4.7297 },  // UV%
            { mu: 92.9365, sigma: 5.4898 },  // Flow
            { mu: 1.6341, sigma: 1.8581 },   // Influent Turbidity
            { mu: 0.6325, sigma: 0.4388 },   // Effluent Turbidity
            { mu: 8.6380, sigma: 0.4105 },   // pH
            { mu: 2.0431, sigma: 5.9868 }    // Coag PPM
        ];

        // Función de normalización
        function normalize(value, mu, sigma) {
            return (value - mu) / sigma;
        }

        // Función ReLU
        function relu(value) {
            return Math.max(0, value);
        }

        // Cálculo del resultado
        function calculateOutput() {
            const inputs = [
                parseFloat(document.getElementById("tankLevel").value),
                parseFloat(document.getElementById("clSet").value),
                parseFloat(document.getElementById("pump").value),
                parseFloat(document.getElementById("uv").value),
                parseFloat(document.getElementById("flow").value),
                parseFloat(document.getElementById("infTurb").value),
                parseFloat(document.getElementById("effTurb").value),
                parseFloat(document.getElementById("ph").value),
                parseFloat(document.getElementById("coagPPM").value)
            ];

            // Normalización
            const normalizedInputs = inputs.map((value, index) =>
                normalize(value, normalizationData[index].mu, normalizationData[index].sigma)
            );

            // Cálculo de la capa oculta
            const hiddenLayerOutputs = weightsHidden.map((weights, neuronIndex) => {
                const sum = weights.reduce((acc, weight, inputIndex) => 
                    acc + weight * normalizedInputs[inputIndex], biasesHidden[neuronIndex]
                );
                return relu(sum);
            });

            // Cálculo de la salida
            const output = hiddenLayerOutputs.reduce((acc, value, index) =>
                acc + value * weightsOutput[index], biasOutput
            );

            // Mostrar el resultado
            document.getElementById("output").innerText = `Output: ${output.toFixed(4)}`;

            // Dibujar el gráfico de la red
            drawNetwork(normalizedInputs, hiddenLayerOutputs, output);
        }

        // Función para dibujar la red neuronal
        function drawNetwork(inputs, hiddenOutputs, output) {
            const canvas = document.getElementById("nn-canvas");
            const ctx = canvas.getContext("2d");

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const inputLayerX = 100;
            const hiddenLayerX = 350;
            const outputLayerX = 600;
            const layerY = 250;

            // Dibujar las entradas
            const inputSpacing = 50;
            inputs.forEach((input, i) => {
                const y = layerY - (inputs.length / 2 - i) * inputSpacing;
                ctx.beginPath();
                ctx.arc(inputLayerX, y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = "#3498DB";
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "black";
                ctx.fillText(`x${i + 1}: ${input.toFixed(2)}`, inputLayerX - 75, y);
            });

            // Dibujar la capa oculta
            const hiddenSpacing = 70;
            hiddenOutputs.forEach((output, i) => {
                const y = layerY - (hiddenOutputs.length / 2 - i) * hiddenSpacing;
                ctx.beginPath();
                ctx.arc(hiddenLayerX, y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = "#F39C12";
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "black";
                ctx.fillText(`h${i + 1}: ${output.toFixed(2)}`, hiddenLayerX + 25, y);
            });

            // Dibujar la salida
            ctx.beginPath();
            ctx.arc(outputLayerX, layerY, 20, 0, 2 * Math.PI);
            ctx.fillStyle = "#28B463";
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.fillText(`y: ${output.toFixed(2)}`, outputLayerX + 25, layerY);

            // Dibujar conexiones entre las capas
            inputs.forEach((_, i) => {
                hiddenOutputs.forEach((_, j) => {
                    const yInput = layerY - (inputs.length / 2 - i) * inputSpacing;
                    const yHidden = layerY - (hiddenOutputs.length / 2 - j) * hiddenSpacing;
                    ctx.beginPath();
                    ctx.moveTo(inputLayerX, yInput);
                    ctx.lineTo(hiddenLayerX, yHidden);
                    ctx.stroke();
                });
            });

            hiddenOutputs.forEach((_, i) => {
                const yHidden = layerY - (hiddenOutputs.length / 2 - i) * hiddenSpacing;
                ctx.beginPath();
                ctx.moveTo(hiddenLayerX, yHidden);
                ctx.lineTo(outputLayerX, layerY);
                ctx.stroke();
            });
        }
    </script>
</body>
</html>



